<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CPPLapack: zgematrix-lapack.hpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">include</a>&nbsp;/&nbsp;<a class="el" href="dir_000026.html">zgematrix-</a></div>
<h1>zgematrix-lapack.hpp</h1><a href="zgematrix-lapack_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">//=============================================================================</span><span class="comment"></span>
00002 <span class="comment">/*! solve A*X=Y using zgesv\n</span>
00003 <span class="comment">  The argument is zgematrix Y. Y is overwritten and become the solution X.</span>
00004 <span class="comment">  A is also overwritten and become P*L*U. */</span>
<a name="l00005"></a><a class="code" href="classzgematrix.html#a24">00005</a> <span class="keyword">inline</span> <span class="keywordtype">long</span> <a class="code" href="classzgematrix.html#a24">zgematrix::zgesv</a>(<a class="code" href="classzgematrix.html">zgematrix</a>&amp; mat)
00006 {
00007 <span class="preprocessor">#ifdef  CPPL_VERBOSE</span>
00008 <span class="preprocessor"></span>  std::cerr &lt;&lt; <span class="stringliteral">"# [MARK] zgematrix::zgesv(zgematrix&amp;)"</span>
00009             &lt;&lt; std::endl;
00010 <span class="preprocessor">#endif//CPPL_VERBOSE</span>
00011 <span class="preprocessor"></span>  
00012 <span class="preprocessor">#ifdef  CPPL_DEBUG</span>
00013 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(<a class="code" href="classzgematrix.html#r0">M</a>!=<a class="code" href="classzgematrix.html#r1">N</a> || <a class="code" href="classzgematrix.html#r0">M</a>!=mat.M){
00014     std::cerr &lt;&lt; <span class="stringliteral">"[ERROR] zgematrix::zgesv(zgematrix&amp;) "</span> &lt;&lt; std::endl
00015               &lt;&lt; <span class="stringliteral">"These two matrices cannot be solved."</span> &lt;&lt; std::endl
00016               &lt;&lt; <span class="stringliteral">"Your input was ("</span> &lt;&lt; <a class="code" href="classzgematrix.html#r0">M</a> &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; <a class="code" href="classzgematrix.html#r1">N</a> &lt;&lt; <span class="stringliteral">") and ("</span>
00017               &lt;&lt; mat.M &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; mat.N &lt;&lt; <span class="stringliteral">")."</span> &lt;&lt; std::endl;
00018     exit(1);
00019   }
00020 <span class="preprocessor">#endif//CPPL_DEBUG </span>
00021 <span class="preprocessor"></span>  
00022   <span class="keywordtype">long</span> NRHS(mat.N), LDA(<a class="code" href="classzgematrix.html#r1">N</a>), *IPIV(<span class="keyword">new</span> <span class="keywordtype">long</span>[<a class="code" href="classzgematrix.html#r1">N</a>]), LDB(mat.M), INFO(1);
00023   zgesv_(N, NRHS, <a class="code" href="classzgematrix.html#r2">Array</a>, LDA, IPIV, mat.Array, LDB, INFO);
00024   <span class="keyword">delete</span> [] IPIV;
00025   
00026   <span class="keywordflow">if</span>(INFO!=0){
00027     std::cerr &lt;&lt; <span class="stringliteral">"[WARNING] zgematrix::zgesv(zgematrix&amp;) "</span>
00028               &lt;&lt; <span class="stringliteral">"Serious trouble happend. INFO = "</span> &lt;&lt; INFO &lt;&lt; <span class="stringliteral">"."</span>
00029               &lt;&lt; std::endl;
00030   }
00031   <span class="keywordflow">return</span> INFO;
00032 }
00033 
00034 <span class="comment">//=============================================================================</span><span class="comment"></span>
00035 <span class="comment">/*! solve A*x=y using zgesv\n</span>
00036 <span class="comment">  The argument is zcovector y. y is overwritten and become the solution x.</span>
00037 <span class="comment">  A is also overwritten and become P*L*U. */</span>
<a name="l00038"></a><a class="code" href="classzgematrix.html#a25">00038</a> <span class="keyword">inline</span> <span class="keywordtype">long</span> <a class="code" href="classzgematrix.html#a24">zgematrix::zgesv</a>(<a class="code" href="classzcovector.html">zcovector</a>&amp; vec)
00039 {
00040 <span class="preprocessor">#ifdef  CPPL_VERBOSE</span>
00041 <span class="preprocessor"></span>  std::cerr &lt;&lt; <span class="stringliteral">"# [MARK] zgematrix::zgesv(zcovector&amp;)"</span>
00042             &lt;&lt; std::endl;
00043 <span class="preprocessor">#endif//CPPL_VERBOSE</span>
00044 <span class="preprocessor"></span>  
00045 <span class="preprocessor">#ifdef  CPPL_DEBUG</span>
00046 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(<a class="code" href="classzgematrix.html#r0">M</a>!=<a class="code" href="classzgematrix.html#r1">N</a> || <a class="code" href="classzgematrix.html#r0">M</a>!=vec.L){
00047     std::cerr &lt;&lt; <span class="stringliteral">"[ERROR] zgematrix::zgesv(zcovector&amp;) "</span> &lt;&lt; std::endl
00048               &lt;&lt; <span class="stringliteral">"These matrix and vector cannot be solved."</span> &lt;&lt; std::endl
00049               &lt;&lt; <span class="stringliteral">"Your input was ("</span> &lt;&lt; <a class="code" href="classzgematrix.html#r0">M</a> &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; <a class="code" href="classzgematrix.html#r1">N</a> &lt;&lt; <span class="stringliteral">") and ("</span>
00050               &lt;&lt; vec.L &lt;&lt; <span class="stringliteral">")."</span> &lt;&lt; std::endl;
00051     exit(1);
00052   }
00053 <span class="preprocessor">#endif//CPPL_DEBUG </span>
00054 <span class="preprocessor"></span>  <span class="keywordtype">long</span> NRHS(1), LDA(<a class="code" href="classzgematrix.html#r1">N</a>), *IPIV(<span class="keyword">new</span> <span class="keywordtype">long</span>[<a class="code" href="classzgematrix.html#r1">N</a>]), LDB(vec.L), INFO(1);
00055   zgesv_(N, NRHS, <a class="code" href="classzgematrix.html#r2">Array</a>, LDA, IPIV, vec.Array, LDB, INFO);
00056   <span class="keyword">delete</span> [] IPIV;
00057   
00058   <span class="keywordflow">if</span>(INFO!=0){
00059     std::cerr &lt;&lt; <span class="stringliteral">"[WARNING] zgematrix::zgesv(zcovector&amp;) "</span>
00060               &lt;&lt; <span class="stringliteral">"Serious trouble happend. INFO = "</span> &lt;&lt; INFO &lt;&lt; <span class="stringliteral">"."</span>
00061               &lt;&lt; std::endl;
00062   }
00063   <span class="keywordflow">return</span> INFO;
00064 }
00065 <span class="comment"></span>
00066 <span class="comment">///////////////////////////////////////////////////////////////////////////////</span>
00067 <span class="comment">///////////////////////////////////////////////////////////////////////////////</span>
00068 <span class="comment">///////////////////////////////////////////////////////////////////////////////</span>
00069 <span class="comment"></span>
00070 <span class="comment">//=============================================================================</span><span class="comment"></span>
00071 <span class="comment">/*! solve overdetermined or underdetermined A*X=Y using zgels\n*/</span>
<a name="l00072"></a><a class="code" href="classzgematrix.html#a26">00072</a> <span class="keyword">inline</span> <span class="keywordtype">long</span> <a class="code" href="classzgematrix.html#a26">zgematrix::zgels</a>(<a class="code" href="classzgematrix.html">zgematrix</a>&amp; mat)
00073 {
00074 <span class="preprocessor">#ifdef  CPPL_VERBOSE</span>
00075 <span class="preprocessor"></span>  std::cerr &lt;&lt; <span class="stringliteral">"# [MARK] zgematrix::zgels(zgematrix&amp;)"</span>
00076             &lt;&lt; std::endl;
00077 <span class="preprocessor">#endif//CPPL_VERBOSE</span>
00078 <span class="preprocessor"></span>  
00079 <span class="preprocessor">#ifdef  CPPL_DEBUG</span>
00080 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(<a class="code" href="classzgematrix.html#r0">M</a>!=mat.M){
00081     std::cerr &lt;&lt; <span class="stringliteral">"[ERROR] zgematrix::zgels(zgematrix&amp;) "</span> &lt;&lt; std::endl
00082               &lt;&lt; <span class="stringliteral">"These two matrices cannot be solved."</span> &lt;&lt; std::endl
00083               &lt;&lt; <span class="stringliteral">"Your input was ("</span> &lt;&lt; <a class="code" href="classzgematrix.html#r0">M</a> &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; <a class="code" href="classzgematrix.html#r1">N</a> &lt;&lt; <span class="stringliteral">") and ("</span>
00084               &lt;&lt; mat.M &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; mat.N &lt;&lt; <span class="stringliteral">")."</span> &lt;&lt; std::endl;
00085     exit(1);
00086   }
00087 <span class="preprocessor">#endif//CPPL_DEBUG    </span>
00088 <span class="preprocessor"></span>  
00089   <span class="keywordflow">if</span>(<a class="code" href="classzgematrix.html#r0">M</a>&lt;<a class="code" href="classzgematrix.html#r1">N</a>){ <span class="comment">//underdetermined</span>
00090     <a class="code" href="classzgematrix.html">zgematrix</a> tmp(<a class="code" href="classzgematrix.html#r1">N</a>,mat.N);
00091     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> <a class="code" href="classzgematrix.html#n15">i</a>=0; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>&lt;mat.<a class="code" href="class__dgematrix.html#o0">M</a>; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>++){ <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j=0; j&lt;mat.N; j++){
00092       tmp(<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>,j) =mat(<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>,j);
00093     }}
00094     mat.clear();
00095     <a class="code" href="classzgematrix.html#n12">swap</a>(mat,tmp);
00096   }
00097   
00098   <span class="keywordtype">char</span> TRANS(<span class="charliteral">'N'</span>);
00099   <span class="keywordtype">long</span> NRHS(mat.N), LDA(<a class="code" href="classzgematrix.html#r0">M</a>), LDB(mat.M),
00100     LWORK(min(<a class="code" href="classzgematrix.html#r0">M</a>,<a class="code" href="classzgematrix.html#r1">N</a>)+max(min(<a class="code" href="classzgematrix.html#r0">M</a>,<a class="code" href="classzgematrix.html#r1">N</a>),NRHS)), INFO(1);
00101   std::complex&lt;double&gt; *WORK(<span class="keyword">new</span> std::complex&lt;double&gt;[LWORK]);
00102   zgels_(TRANS, <a class="code" href="classzgematrix.html#r0">M</a>, <a class="code" href="classzgematrix.html#r1">N</a>, NRHS, <a class="code" href="classzgematrix.html#r2">Array</a>, LDA, mat.Array, LDB, WORK, LWORK, INFO);
00103   <span class="keyword">delete</span> [] WORK;
00104   
00105   <span class="keywordflow">if</span>(<a class="code" href="classzgematrix.html#r0">M</a>&gt;<a class="code" href="classzgematrix.html#r1">N</a>){ <span class="comment">//overdetermined</span>
00106     <a class="code" href="classzgematrix.html">zgematrix</a> tmp(<a class="code" href="classzgematrix.html#r1">N</a>,mat.N);
00107     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> <a class="code" href="classzgematrix.html#n15">i</a>=0; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>&lt;tmp.<a class="code" href="class__dgematrix.html#o0">M</a>; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>++){ <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j=0; j&lt;tmp.N; j++){
00108       tmp(<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>,j) =mat(<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>,j);
00109     }}
00110     mat.clear();
00111     <a class="code" href="classzgematrix.html#n12">swap</a>(mat,tmp);
00112   }
00113   
00114   <span class="keywordflow">if</span>(INFO!=0){
00115     std::cerr &lt;&lt; <span class="stringliteral">"[WARNING] zgematrix::zgels(zgematrix&amp;) "</span>
00116               &lt;&lt; <span class="stringliteral">"Serious trouble happend. INFO = "</span> &lt;&lt; INFO &lt;&lt; <span class="stringliteral">"."</span>
00117               &lt;&lt; std::endl;
00118   }
00119   <span class="keywordflow">return</span> INFO;
00120 }
00121 
00122 <span class="comment">//=============================================================================</span><span class="comment"></span>
00123 <span class="comment">/*! solve overdetermined or underdetermined A*x=y using zgels\n*/</span>
<a name="l00124"></a><a class="code" href="classzgematrix.html#a27">00124</a> <span class="keyword">inline</span> <span class="keywordtype">long</span> <a class="code" href="classzgematrix.html#a26">zgematrix::zgels</a>(<a class="code" href="classzcovector.html">zcovector</a>&amp; vec)
00125 {
00126 <span class="preprocessor">#ifdef  CPPL_VERBOSE</span>
00127 <span class="preprocessor"></span>  std::cerr &lt;&lt; <span class="stringliteral">"# [MARK] zgematrix::zgels(zcovector&amp;)"</span>
00128             &lt;&lt; std::endl;
00129 <span class="preprocessor">#endif//CPPL_VERBOSE</span>
00130 <span class="preprocessor"></span>  
00131 <span class="preprocessor">#ifdef  CPPL_DEBUG</span>
00132 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(<a class="code" href="classzgematrix.html#r0">M</a>!=vec.L){
00133     std::cerr &lt;&lt; <span class="stringliteral">"[ERROR] zgematrix::zgels(zcovector&amp;) "</span> &lt;&lt; std::endl
00134               &lt;&lt; <span class="stringliteral">"These matrix and vector cannot be solved."</span> &lt;&lt; std::endl
00135               &lt;&lt; <span class="stringliteral">"Your input was ("</span> &lt;&lt; <a class="code" href="classzgematrix.html#r0">M</a> &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; <a class="code" href="classzgematrix.html#r1">N</a> &lt;&lt; <span class="stringliteral">") and ("</span>
00136               &lt;&lt; vec.L &lt;&lt; <span class="stringliteral">")."</span> &lt;&lt; std::endl;
00137     exit(1);
00138   }
00139 <span class="preprocessor">#endif//CPPL_DEBUG    </span>
00140 <span class="preprocessor"></span>  
00141   <span class="keywordflow">if</span>(<a class="code" href="classzgematrix.html#r0">M</a>&lt;<a class="code" href="classzgematrix.html#r1">N</a>){ <span class="comment">//underdetermined</span>
00142     <a class="code" href="classzcovector.html">zcovector</a> tmp(<a class="code" href="classzgematrix.html#r1">N</a>);
00143     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> <a class="code" href="classzgematrix.html#n15">i</a>=0; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>&lt;vec.L; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>++){ tmp(<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>)=vec(<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>); }
00144     vec.<a class="code" href="classzcovector.html#a11">clear</a>();
00145     <a class="code" href="classzgematrix.html#n12">swap</a>(vec,tmp);
00146   }
00147   
00148   <span class="keywordtype">char</span> TRANS(<span class="charliteral">'N'</span>);
00149   <span class="keywordtype">long</span> NRHS(1), LDA(<a class="code" href="classzgematrix.html#r0">M</a>), LDB(vec.L),
00150     LWORK(min(<a class="code" href="classzgematrix.html#r0">M</a>,<a class="code" href="classzgematrix.html#r1">N</a>)+max(min(<a class="code" href="classzgematrix.html#r0">M</a>,<a class="code" href="classzgematrix.html#r1">N</a>),NRHS)), INFO(1);
00151   std::complex&lt;double&gt; *WORK(<span class="keyword">new</span> std::complex&lt;double&gt;[LWORK]);
00152   zgels_(TRANS, <a class="code" href="classzgematrix.html#r0">M</a>, <a class="code" href="classzgematrix.html#r1">N</a>, NRHS, <a class="code" href="classzgematrix.html#r2">Array</a>, LDA, vec.Array, LDB, WORK, LWORK, INFO);
00153   <span class="keyword">delete</span> [] WORK;
00154   
00155   <span class="keywordflow">if</span>(<a class="code" href="classzgematrix.html#r0">M</a>&gt;<a class="code" href="classzgematrix.html#r1">N</a>){ <span class="comment">//overdetermined</span>
00156     <a class="code" href="classzcovector.html">zcovector</a> tmp(<a class="code" href="classzgematrix.html#r1">N</a>);
00157     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> <a class="code" href="classzgematrix.html#n15">i</a>=0; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>&lt;tmp.<a class="code" href="classzcovector.html#r0">L</a>; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>++){ tmp(<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>)=vec(<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>); }
00158     vec.<a class="code" href="classzcovector.html#a11">clear</a>();
00159     <a class="code" href="classzgematrix.html#n12">swap</a>(vec,tmp);
00160   }
00161   
00162   <span class="keywordflow">if</span>(INFO!=0){
00163     std::cerr &lt;&lt; <span class="stringliteral">"[WARNING] zgematrix::zgels(zcovector&amp;) "</span>
00164               &lt;&lt; <span class="stringliteral">"Serious trouble happend. INFO = "</span> &lt;&lt; INFO &lt;&lt; <span class="stringliteral">"."</span>
00165               &lt;&lt; std::endl;
00166   }
00167   <span class="keywordflow">return</span> INFO;
00168 }
00169 
00170 <span class="comment">//=============================================================================</span><span class="comment"></span>
00171 <span class="comment">/*! solve overdetermined or underdetermined A*X=Y using zgels</span>
00172 <span class="comment">  with the sum of residual squares output\n</span>
00173 <span class="comment">  The residual is set as the columnwise sum of residual squares </span>
00174 <span class="comment">  for overdetermined problems </span>
00175 <span class="comment">  while it is always zero for underdetermined problems.</span>
00176 <span class="comment">*/</span>
<a name="l00177"></a><a class="code" href="classzgematrix.html#a28">00177</a> <span class="keyword">inline</span> <span class="keywordtype">long</span> <a class="code" href="classzgematrix.html#a26">zgematrix::zgels</a>(<a class="code" href="classzgematrix.html">zgematrix</a>&amp; mat, <a class="code" href="classdrovector.html">drovector</a>&amp; residual)
00178 {
00179 <span class="preprocessor">#ifdef  CPPL_VERBOSE</span>
00180 <span class="preprocessor"></span>  std::cerr &lt;&lt; <span class="stringliteral">"# [MARK] zgematrix::zgels(zgematrix&amp;, drovector&amp;)"</span>
00181             &lt;&lt; std::endl;
00182 <span class="preprocessor">#endif//CPPL_VERBOSE</span>
00183 <span class="preprocessor"></span>  
00184 <span class="preprocessor">#ifdef  CPPL_DEBUG</span>
00185 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(<a class="code" href="classzgematrix.html#r0">M</a>!=mat.M){
00186     std::cerr &lt;&lt; <span class="stringliteral">"[ERROR] zgematrix::zgels(zgematrix&amp;, drovector&amp;) "</span>
00187               &lt;&lt; std::endl
00188               &lt;&lt; <span class="stringliteral">"These two matrices cannot be solved."</span> &lt;&lt; std::endl
00189               &lt;&lt; <span class="stringliteral">"Your input was ("</span> &lt;&lt; <a class="code" href="classzgematrix.html#r0">M</a> &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; <a class="code" href="classzgematrix.html#r1">N</a> &lt;&lt; <span class="stringliteral">") and ("</span>
00190               &lt;&lt; mat.M &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; mat.N &lt;&lt; <span class="stringliteral">")."</span> &lt;&lt; std::endl;
00191     exit(1);
00192   }
00193 <span class="preprocessor">#endif//CPPL_DEBUG</span>
00194 <span class="preprocessor"></span>  
00195   residual.<a class="code" href="classzcovector.html#a16">resize</a>(mat.N); residual.<a class="code" href="classzcovector.html#a12">zero</a>();
00196   
00197   <span class="keywordflow">if</span>(<a class="code" href="classzgematrix.html#r0">M</a>&lt;<a class="code" href="classzgematrix.html#r1">N</a>){ <span class="comment">//underdetermined</span>
00198     <a class="code" href="classzgematrix.html">zgematrix</a> tmp(<a class="code" href="classzgematrix.html#r1">N</a>,mat.N);
00199     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> <a class="code" href="classzgematrix.html#n15">i</a>=0; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>&lt;mat.<a class="code" href="class__dgematrix.html#o0">M</a>; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>++){ <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j=0; j&lt;mat.N; j++){
00200       tmp(<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>,j) =mat(<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>,j);
00201     }}
00202     mat.<a class="code" href="classzcovector.html#a11">clear</a>();
00203     <a class="code" href="classzgematrix.html#n12">swap</a>(mat,tmp);
00204   }
00205   
00206   <span class="keywordtype">char</span> TRANS(<span class="charliteral">'N'</span>);
00207   <span class="keywordtype">long</span> NRHS(mat.N), LDA(<a class="code" href="classzgematrix.html#r0">M</a>), LDB(mat.M),
00208     LWORK(min(<a class="code" href="classzgematrix.html#r0">M</a>,<a class="code" href="classzgematrix.html#r1">N</a>)+max(min(<a class="code" href="classzgematrix.html#r0">M</a>,<a class="code" href="classzgematrix.html#r1">N</a>),NRHS)), INFO(1);
00209   std::complex&lt;double&gt; *WORK(<span class="keyword">new</span> std::complex&lt;double&gt;[LWORK]);
00210   zgels_(TRANS, <a class="code" href="classzgematrix.html#r0">M</a>, <a class="code" href="classzgematrix.html#r1">N</a>, NRHS, <a class="code" href="classzgematrix.html#r2">Array</a>, LDA, mat.Array, LDB, WORK, LWORK, INFO);
00211   <span class="keyword">delete</span> [] WORK;
00212   
00213   <span class="keywordflow">if</span>(<a class="code" href="classzgematrix.html#r0">M</a>&gt;<a class="code" href="classzgematrix.html#r1">N</a>){ <span class="comment">//overdetermined</span>
00214     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> <a class="code" href="classzgematrix.html#n15">i</a>=0; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>&lt;residual.l; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>++){ <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j=0; j&lt;<a class="code" href="classzgematrix.html#r0">M</a>-<a class="code" href="classzgematrix.html#r1">N</a>; j++){
00215       residual(<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>) += std::norm(mat(N+j,<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>));
00216     }}
00217     
00218     <a class="code" href="classzgematrix.html">zgematrix</a> tmp(<a class="code" href="classzgematrix.html#r1">N</a>,mat.N);
00219     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>=0; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>&lt;tmp.<a class="code" href="class__dgematrix.html#o0">M</a>; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>++){ <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j=0; j&lt;tmp.N; j++){
00220       tmp(<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>,j) =mat(<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>,j);
00221     }}
00222     mat.<a class="code" href="classzcovector.html#a11">clear</a>();
00223     <a class="code" href="classzgematrix.html#n12">swap</a>(mat,tmp);
00224   }
00225   
00226   <span class="keywordflow">if</span>(INFO!=0){
00227     std::cerr &lt;&lt; <span class="stringliteral">"[WARNING] zgematrix::zgels(zgematrix&amp;, drovector&amp;) "</span>
00228               &lt;&lt; <span class="stringliteral">"Serious trouble happend. INFO = "</span> &lt;&lt; INFO &lt;&lt; <span class="stringliteral">"."</span>
00229               &lt;&lt; std::endl;
00230   }
00231   <span class="keywordflow">return</span> INFO;
00232 }
00233 
00234 <span class="comment">//=============================================================================</span><span class="comment"></span>
00235 <span class="comment">/*! solve overdetermined or underdetermined A*x=y using zgels</span>
00236 <span class="comment">  with the sum of residual squares output\n</span>
00237 <span class="comment">  The residual is set as the sum of residual squares for overdetermined problems</span>
00238 <span class="comment">  while it is always zero for underdetermined problems.</span>
00239 <span class="comment">*/</span>
<a name="l00240"></a><a class="code" href="classzgematrix.html#a29">00240</a> <span class="keyword">inline</span> <span class="keywordtype">long</span> <a class="code" href="classzgematrix.html#a26">zgematrix::zgels</a>(<a class="code" href="classzcovector.html">zcovector</a>&amp; vec, <span class="keywordtype">double</span>&amp; residual)
00241 {
00242 <span class="preprocessor">#ifdef  CPPL_VERBOSE</span>
00243 <span class="preprocessor"></span>  std::cerr &lt;&lt; <span class="stringliteral">"# [MARK] zgematrix::zgels(zcovector&amp;, double&amp;)"</span>
00244             &lt;&lt; std::endl;
00245 <span class="preprocessor">#endif//CPPL_VERBOSE</span>
00246 <span class="preprocessor"></span>  
00247 <span class="preprocessor">#ifdef  CPPL_DEBUG</span>
00248 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(<a class="code" href="classzgematrix.html#r0">M</a>!=vec.L){
00249     std::cerr &lt;&lt; <span class="stringliteral">"[ERROR] zgematrix::zgels(zcovector&amp;, double&amp;) "</span> &lt;&lt; std::endl
00250               &lt;&lt; <span class="stringliteral">"These matrix and vector cannot be solved."</span> &lt;&lt; std::endl
00251               &lt;&lt; <span class="stringliteral">"Your input was ("</span> &lt;&lt; <a class="code" href="classzgematrix.html#r0">M</a> &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; <a class="code" href="classzgematrix.html#r1">N</a> &lt;&lt; <span class="stringliteral">") and ("</span>
00252               &lt;&lt; vec.<a class="code" href="classzcovector.html#r0">L</a> &lt;&lt; <span class="stringliteral">")."</span> &lt;&lt; std::endl;
00253     exit(1);
00254   }
00255 <span class="preprocessor">#endif//CPPL_DEBUG    </span>
00256 <span class="preprocessor"></span>  
00257   residual=0.0;
00258   
00259   <span class="keywordflow">if</span>(<a class="code" href="classzgematrix.html#r0">M</a>&lt;<a class="code" href="classzgematrix.html#r1">N</a>){ <span class="comment">//underdetermined</span>
00260     <a class="code" href="classzcovector.html">zcovector</a> tmp(<a class="code" href="classzgematrix.html#o1">n</a>);
00261     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> <a class="code" href="classzgematrix.html#n15">i</a>=0; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>&lt;vec.L; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>++){ tmp(<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>)=vec(<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>); }
00262     vec.<a class="code" href="classzcovector.html#a11">clear</a>();
00263     <a class="code" href="classzgematrix.html#n12">swap</a>(vec,tmp);
00264   }
00265   
00266   <span class="keywordtype">char</span> TRANS(<span class="charliteral">'N'</span>);
00267   <span class="keywordtype">long</span> NRHS(1), LDA(<a class="code" href="classzgematrix.html#o0">m</a>), LDB(vec.L),
00268     LWORK(min(<a class="code" href="classzgematrix.html#r0">M</a>,<a class="code" href="classzgematrix.html#r1">N</a>)+max(min(<a class="code" href="classzgematrix.html#r0">M</a>,<a class="code" href="classzgematrix.html#r1">N</a>),NRHS)), INFO(1);
00269   std::complex&lt;double&gt; *WORK(<span class="keyword">new</span> std::complex&lt;double&gt;[LWORK]);
00270   zgels_(TRANS, <a class="code" href="classzgematrix.html#r0">M</a>, <a class="code" href="classzgematrix.html#r1">N</a>, NRHS, <a class="code" href="classzgematrix.html#r2">Array</a>, LDA, vec.Array, LDB, WORK, LWORK, INFO);
00271   <span class="keyword">delete</span> [] WORK;
00272   
00273   <span class="keywordflow">if</span>(<a class="code" href="classzgematrix.html#r0">M</a>&gt;<a class="code" href="classzgematrix.html#r1">N</a>){ <span class="comment">//overdetermined</span>
00274     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> <a class="code" href="classzgematrix.html#n15">i</a>=0; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>&lt;<a class="code" href="classzgematrix.html#r0">M</a>-<a class="code" href="classzgematrix.html#r1">N</a>; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>++){ residual+=std::norm(vec(N+<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>)); }
00275     
00276     <a class="code" href="classzcovector.html">zcovector</a> tmp(N);
00277     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>=0; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>&lt;tmp.<a class="code" href="classzcovector.html#r0">L</a>; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>++){ tmp(<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>)=vec(<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>); }
00278     vec.<a class="code" href="classzcovector.html#a11">clear</a>();
00279     <a class="code" href="classzgematrix.html#n12">swap</a>(vec,tmp);
00280   }
00281   
00282   <span class="keywordflow">if</span>(INFO!=0){
00283     std::cerr &lt;&lt; <span class="stringliteral">"[WARNING] zgematrix::zgels(zcovector&amp;, double&amp;) "</span>
00284               &lt;&lt; <span class="stringliteral">"Serious trouble happend. INFO = "</span> &lt;&lt; INFO &lt;&lt; <span class="stringliteral">"."</span>
00285               &lt;&lt; std::endl;
00286   }
00287   <span class="keywordflow">return</span> INFO;
00288 }
00289 <span class="comment"></span>
00290 <span class="comment">///////////////////////////////////////////////////////////////////////////////</span>
00291 <span class="comment">///////////////////////////////////////////////////////////////////////////////</span>
00292 <span class="comment">///////////////////////////////////////////////////////////////////////////////</span>
00293 <span class="comment"></span>
00294 <span class="comment">//=============================================================================</span><span class="comment"></span>
00295 <span class="comment">/*! calculate the least-squares-least-norm solution </span>
00296 <span class="comment">  for overdetermined or underdetermined A*x=y using zgelss\n */</span>
<a name="l00297"></a><a class="code" href="classzgematrix.html#a30">00297</a> <span class="keyword">inline</span> <span class="keywordtype">long</span> <a class="code" href="classzgematrix.html#a30">zgematrix::zgelss</a>(<a class="code" href="classzcovector.html">zcovector</a>&amp; B, <a class="code" href="classdcovector.html">dcovector</a>&amp; S, <span class="keywordtype">long</span>&amp; RANK,
00298                               <span class="keyword">const</span> <span class="keywordtype">double</span> RCOND =-1. )
00299 {
00300 <span class="preprocessor">#ifdef  CPPL_VERBOSE</span>
00301 <span class="preprocessor"></span>  std::cerr &lt;&lt; <span class="stringliteral">"# [MARK] zgematrix::zgelss(zcovector&amp;, dcovector&amp;, long&amp;, const double)"</span>
00302             &lt;&lt; std::endl;
00303 <span class="preprocessor">#endif//CPPL_VERBOSE</span>
00304 <span class="preprocessor"></span>  
00305 <span class="preprocessor">#ifdef  CPPL_DEBUG</span>
00306 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(<a class="code" href="classzgematrix.html#r0">M</a>!=B.L){
00307     std::cerr &lt;&lt; <span class="stringliteral">"[ERROR] zgematrix::zgelss"</span>
00308               &lt;&lt; <span class="stringliteral">"(zcovector&amp;, dcovector&amp;, long&amp;, const double) "</span> &lt;&lt; std::endl
00309               &lt;&lt; <span class="stringliteral">"These matrix and vector cannot be solved."</span> &lt;&lt; std::endl
00310               &lt;&lt; <span class="stringliteral">"Your input was ("</span> &lt;&lt; <a class="code" href="classzgematrix.html#r0">M</a> &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; <a class="code" href="classzgematrix.html#r1">N</a> &lt;&lt; <span class="stringliteral">") and ("</span>
00311               &lt;&lt; B.<a class="code" href="classzcovector.html#r0">L</a> &lt;&lt; <span class="stringliteral">")."</span> &lt;&lt; std::endl;
00312     exit(1);
00313   }
00314 <span class="preprocessor">#endif//CPPL_DEBUG    </span>
00315 <span class="preprocessor"></span>  
00316   <span class="keywordflow">if</span>(<a class="code" href="classzgematrix.html#r0">M</a>&lt;<a class="code" href="classzgematrix.html#r1">N</a>){ <span class="comment">//underdetermined</span>
00317     <a class="code" href="classzcovector.html">zcovector</a> tmp(<a class="code" href="classzgematrix.html#r1">N</a>);
00318     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> <a class="code" href="classzgematrix.html#n15">i</a>=0; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>&lt;B.L; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>++){ tmp(<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>)=B(<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>); }
00319     B.<a class="code" href="classzcovector.html#a11">clear</a>();
00320     <a class="code" href="classzgematrix.html#n12">swap</a>(B,tmp);
00321   }
00322   
00323   S.<a class="code" href="classzcovector.html#a16">resize</a>(min(<a class="code" href="classzgematrix.html#r0">M</a>,<a class="code" href="classzgematrix.html#r1">N</a>));
00324   
00325   <span class="keywordtype">long</span> NRHS(1), LDA(<a class="code" href="classzgematrix.html#r0">M</a>), LDB(B.L),
00326     LWORK(2*min(<a class="code" href="classzgematrix.html#r0">M</a>,<a class="code" href="classzgematrix.html#r1">N</a>) +max(max(<a class="code" href="classzgematrix.html#r0">M</a>,<a class="code" href="classzgematrix.html#r1">N</a>),NRHS)), INFO(1);
00327   <span class="keywordtype">double</span> *RWORK(<span class="keyword">new</span> <span class="keywordtype">double</span>[5*min(<a class="code" href="classzgematrix.html#r0">M</a>,<a class="code" href="classzgematrix.html#r1">N</a>)]);
00328   std::complex&lt;double&gt; *WORK(<span class="keyword">new</span> std::complex&lt;double&gt;[LWORK]);
00329   zgelss_(<a class="code" href="classzgematrix.html#r0">M</a>, <a class="code" href="classzgematrix.html#r1">N</a>, NRHS, <a class="code" href="classzgematrix.html#r2">Array</a>, LDA, B.Array, LDB, S.array, RCOND, RANK, 
00330           WORK, LWORK, RWORK, INFO);
00331   <span class="keyword">delete</span> [] RWORK; <span class="keyword">delete</span> [] WORK;
00332   
00333   <span class="keywordflow">if</span>(INFO!=0){
00334     std::cerr &lt;&lt; <span class="stringliteral">"[WARNING] zgematrix::zgelss"</span>
00335               &lt;&lt; <span class="stringliteral">"(zcovector&amp;, dcovector&amp;, long&amp;, double) "</span>
00336               &lt;&lt; <span class="stringliteral">"Serious trouble happend. INFO = "</span> &lt;&lt; INFO &lt;&lt; <span class="stringliteral">"."</span>
00337               &lt;&lt; std::endl;
00338   }
00339   <span class="keywordflow">return</span> INFO;
00340 }
00341 
00342 <span class="comment">//=============================================================================</span><span class="comment"></span>
00343 <span class="comment">/*! calculate the least-squares-least-norm solution </span>
00344 <span class="comment">  for overdetermined or underdetermined A*x=y using zgelss\n */</span>
<a name="l00345"></a><a class="code" href="classzgematrix.html#a31">00345</a> <span class="keyword">inline</span> <span class="keywordtype">long</span> <a class="code" href="classzgematrix.html#a30">zgematrix::zgelss</a>(<a class="code" href="classzgematrix.html">zgematrix</a>&amp; B, <a class="code" href="classdcovector.html">dcovector</a>&amp; S, <span class="keywordtype">long</span>&amp; RANK,
00346                               <span class="keyword">const</span> <span class="keywordtype">double</span> RCOND =-1. )
00347 {
00348 <span class="preprocessor">#ifdef  CPPL_VERBOSE</span>
00349 <span class="preprocessor"></span>  std::cerr &lt;&lt; <span class="stringliteral">"# [MARK] zgematrix::zgelss(zgematrix&amp;, dcovector&amp;, long&amp;, const double)"</span>
00350             &lt;&lt; std::endl;
00351 <span class="preprocessor">#endif//CPPL_VERBOSE</span>
00352 <span class="preprocessor"></span>  
00353 <span class="preprocessor">#ifdef  CPPL_DEBUG</span>
00354 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(<a class="code" href="classzgematrix.html#r0">M</a>!=B.M){
00355     std::cerr &lt;&lt; <span class="stringliteral">"[ERROR] zgematrix::zgelss"</span>
00356               &lt;&lt; <span class="stringliteral">"(zgematrix&amp;, dcovector&amp;, long&amp;, const double) "</span> &lt;&lt; std::endl
00357               &lt;&lt; <span class="stringliteral">"These matrix and vector cannot be solved."</span> &lt;&lt; std::endl
00358               &lt;&lt; <span class="stringliteral">"Your input was ("</span> &lt;&lt; <a class="code" href="classzgematrix.html#r0">M</a> &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; <a class="code" href="classzgematrix.html#r1">N</a> &lt;&lt; <span class="stringliteral">") and ("</span>
00359               &lt;&lt; B.M &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; B.N &lt;&lt; <span class="stringliteral">")."</span> &lt;&lt; std::endl;
00360     exit(1);
00361   }
00362 <span class="preprocessor">#endif//CPPL_DEBUG    </span>
00363 <span class="preprocessor"></span>  
00364   <span class="keywordflow">if</span>(<a class="code" href="classzgematrix.html#r0">M</a>&lt;<a class="code" href="classzgematrix.html#r1">N</a>){ <span class="comment">//underdetermined</span>
00365     <a class="code" href="classzgematrix.html">zgematrix</a> tmp(<a class="code" href="classzgematrix.html#r1">N</a>,B.N);
00366     <span class="keywordflow">for</span>(<span class="keywordtype">long</span> <a class="code" href="classzgematrix.html#n15">i</a>=0; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>&lt;B.<a class="code" href="class__dgematrix.html#o0">M</a>; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>++){
00367       <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j=0; j&lt;B.N; j++){
00368         tmp(<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>,j)=B(<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>,j);
00369       }
00370     }
00371     B.<a class="code" href="classzcovector.html#a11">clear</a>();
00372     <a class="code" href="classzgematrix.html#n12">swap</a>(B,tmp);
00373   }
00374   
00375   S.<a class="code" href="classzcovector.html#a16">resize</a>(min(<a class="code" href="classzgematrix.html#r0">M</a>,<a class="code" href="classzgematrix.html#r1">N</a>));
00376   
00377   <span class="keywordtype">long</span> NRHS(B.N), LDA(<a class="code" href="classzgematrix.html#r0">M</a>), LDB(B.M),
00378     LWORK(2*min(<a class="code" href="classzgematrix.html#r0">M</a>,<a class="code" href="classzgematrix.html#r1">N</a>) +max(max(<a class="code" href="classzgematrix.html#r0">M</a>,<a class="code" href="classzgematrix.html#r1">N</a>),NRHS)), INFO(1);
00379   <span class="keywordtype">double</span> *RWORK(<span class="keyword">new</span> <span class="keywordtype">double</span>[5*min(<a class="code" href="classzgematrix.html#r0">M</a>,<a class="code" href="classzgematrix.html#r1">N</a>)]);
00380   std::complex&lt;double&gt; *WORK(<span class="keyword">new</span> std::complex&lt;double&gt;[LWORK]);
00381   zgelss_(<a class="code" href="classzgematrix.html#r0">M</a>, <a class="code" href="classzgematrix.html#r1">N</a>, NRHS, <a class="code" href="classzgematrix.html#r2">Array</a>, LDA, B.Array, LDB, S.array, RCOND, RANK, 
00382           WORK, LWORK, RWORK, INFO);
00383   <span class="keyword">delete</span> [] RWORK; <span class="keyword">delete</span> [] WORK;
00384   
00385   <span class="keywordflow">if</span>(INFO!=0){
00386     std::cerr &lt;&lt; <span class="stringliteral">"[WARNING] zgematrix::zgelss"</span>
00387               &lt;&lt; <span class="stringliteral">"(zgematrix&amp;, dcovector&amp;, long&amp;, const double) "</span>
00388               &lt;&lt; <span class="stringliteral">"Serious trouble happend. INFO = "</span> &lt;&lt; INFO &lt;&lt; <span class="stringliteral">"."</span>
00389               &lt;&lt; std::endl;
00390   }
00391   <span class="keywordflow">return</span> INFO;
00392 }
00393 <span class="comment"></span>
00394 <span class="comment">///////////////////////////////////////////////////////////////////////////////</span>
00395 <span class="comment">///////////////////////////////////////////////////////////////////////////////</span>
00396 <span class="comment">///////////////////////////////////////////////////////////////////////////////</span>
00397 <span class="comment"></span>
00398 <span class="comment">//=============================================================================</span><span class="comment"></span>
00399 <span class="comment">/*! calculate eigenvalues\n</span>
00400 <span class="comment">  The argument need not to be initialized.</span>
00401 <span class="comment">  w is overwitten and become eigenvalues.</span>
00402 <span class="comment">  This matrix is also overwritten. */</span>
<a name="l00403"></a><a class="code" href="classzgematrix.html#a32">00403</a> <span class="keyword">inline</span> <span class="keywordtype">long</span> <a class="code" href="classzgematrix.html#a32">zgematrix::zgeev</a>(std::vector&lt; std::complex&lt;double&gt; &gt;&amp; w)
00404 {
00405 <span class="preprocessor">#ifdef  CPPL_VERBOSE</span>
00406 <span class="preprocessor"></span>  std::cerr &lt;&lt; <span class="stringliteral">"# [MARK] zgematrix::zgeev(std::vector&lt; std::complex&lt;double&gt; &gt;&amp;)"</span>
00407             &lt;&lt; std::endl;
00408 <span class="preprocessor">#endif//CPPL_VERBOSE</span>
00409 <span class="preprocessor"></span>  
00410 <span class="preprocessor">#ifdef  CPPL_DEBUG</span>
00411 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(<a class="code" href="classzgematrix.html#r0">M</a>!=<a class="code" href="classzgematrix.html#r1">N</a>){
00412     std::cerr &lt;&lt; <span class="stringliteral">"[ERROR] zgematrix::zgeev"</span>
00413               &lt;&lt; <span class="stringliteral">"(std::vector&lt;std::complex&lt;double&gt;&gt;&amp;) "</span>
00414               &lt;&lt; std::endl
00415               &lt;&lt; <span class="stringliteral">"This matrix cannot have eigenvalues."</span> &lt;&lt; std::endl
00416               &lt;&lt; <span class="stringliteral">"Your input was ("</span> &lt;&lt; <a class="code" href="classzgematrix.html#r0">M</a> &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; <a class="code" href="classzgematrix.html#r1">N</a> &lt;&lt; <span class="stringliteral">")."</span> &lt;&lt; std::endl;
00417     exit(1);
00418   }
00419 <span class="preprocessor">#endif//CPPL_DEBUG</span>
00420 <span class="preprocessor"></span>  
00421   w.<a class="code" href="classzcovector.html#a16">resize</a>(<a class="code" href="classzgematrix.html#r1">N</a>);
00422   <span class="keywordtype">char</span> JOBVL(<span class="charliteral">'N'</span>), JOBVR(<span class="charliteral">'N'</span>);
00423   <span class="keywordtype">long</span> LDA(<a class="code" href="classzgematrix.html#r1">N</a>), LDVL(1), LDVR(1), LWORK(4*<a class="code" href="classzgematrix.html#o1">n</a>), INFO(1);
00424   <span class="keywordtype">double</span> *RWORK(<span class="keyword">new</span> <span class="keywordtype">double</span>[2*<a class="code" href="classzgematrix.html#o1">n</a>]);
00425   std::complex&lt;double&gt; *VL(NULL), *VR(NULL), 
00426     *WORK(<span class="keyword">new</span> std::complex&lt;double&gt;[LWORK]);
00427   zgeev_(JOBVL, JOBVR, <a class="code" href="classzgematrix.html#r1">N</a>, <a class="code" href="classzgematrix.html#r2">Array</a>, LDA, &amp;w[0], 
00428          VL, LDVL, VR, LDVR, WORK, LWORK, RWORK, INFO);
00429   <span class="keyword">delete</span> [] RWORK; <span class="keyword">delete</span> [] WORK; <span class="keyword">delete</span> [] VL; <span class="keyword">delete</span> [] VR;
00430   
00431   <span class="keywordflow">if</span>(INFO!=0){
00432     std::cerr &lt;&lt; <span class="stringliteral">"[WARNING] zgematrix::zgesv"</span>
00433               &lt;&lt; <span class="stringliteral">"(std::vector&lt;std::complex&lt;double&gt;&amp;, std::vector&lt;zcovector&gt;&amp;) "</span>
00434               &lt;&lt; <span class="stringliteral">"Serious trouble happend. INFO = "</span> &lt;&lt; INFO &lt;&lt; <span class="stringliteral">"."</span>
00435               &lt;&lt; std::endl;
00436   }
00437   <span class="keywordflow">return</span> INFO;
00438 }
00439 
00440 <span class="comment">//=============================================================================</span><span class="comment"></span>
00441 <span class="comment">/*! calculate eigenvalues and right eigenvectors\n</span>
00442 <span class="comment">  All of the arguments need not to be initialized.</span>
00443 <span class="comment">  w, vr are overwitten and become eigenvalues and right eigenvectors, </span>
00444 <span class="comment">  respectively. </span>
00445 <span class="comment">  This matrix is also overwritten. */</span>
<a name="l00446"></a><a class="code" href="classzgematrix.html#a33">00446</a> <span class="keyword">inline</span> <span class="keywordtype">long</span> <a class="code" href="classzgematrix.html#a32">zgematrix::zgeev</a>(std::vector&lt; std::complex&lt;double&gt; &gt;&amp; w,
00447                              std::vector&lt;zcovector&gt;&amp; vr)
00448 {
00449 <span class="preprocessor">#ifdef  CPPL_VERBOSE</span>
00450 <span class="preprocessor"></span>  std::cerr &lt;&lt; <span class="stringliteral">"# [MARK] zgematrix::zgeev(std::vector&lt; std::complex&lt;double&gt; &gt;&amp;, std::vector&lt;zcovector&gt;&amp;)"</span>
00451             &lt;&lt; std::endl;
00452 <span class="preprocessor">#endif//CPPL_VERBOSE</span>
00453 <span class="preprocessor"></span>  
00454 <span class="preprocessor">#ifdef  CPPL_DEBUG</span>
00455 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(<a class="code" href="classzgematrix.html#r0">M</a>!=<a class="code" href="classzgematrix.html#r1">N</a>){
00456     std::cerr &lt;&lt; <span class="stringliteral">"[ERROR] zgematrix::zgeev"</span>
00457               &lt;&lt; <span class="stringliteral">"(std::vector&lt;std::complex&lt;double&gt;&gt;&amp;, std::vector&lt;zcovector&gt;&amp;)"</span>
00458               &lt;&lt; std::endl
00459               &lt;&lt; <span class="stringliteral">"This matrix cannot have eigenvalues."</span> &lt;&lt; std::endl
00460               &lt;&lt; <span class="stringliteral">"Your input was ("</span> &lt;&lt; <a class="code" href="classzgematrix.html#r0">M</a> &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; <a class="code" href="classzgematrix.html#r1">N</a> &lt;&lt; <span class="stringliteral">")."</span> &lt;&lt; std::endl;
00461     exit(1);
00462   }
00463 <span class="preprocessor">#endif//CPPL_DEBUG</span>
00464 <span class="preprocessor"></span>  
00465   w.<a class="code" href="classzcovector.html#a16">resize</a>(<a class="code" href="classzgematrix.html#r1">N</a>);  vr.<a class="code" href="classzcovector.html#a16">resize</a>(<a class="code" href="classzgematrix.html#r1">N</a>);
00466   <span class="keywordflow">for</span>(<span class="keywordtype">long</span> <a class="code" href="classzgematrix.html#n15">i</a>=0; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>&lt;<a class="code" href="classzgematrix.html#r1">N</a>; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>++){ vr[<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>].<a class="code" href="classzcovector.html#a16">resize</a>(N); }
00467   <a class="code" href="classzgematrix.html">zgematrix</a> VR(N,N);
00468   <span class="keywordtype">char</span> JOBVL(<span class="charliteral">'N'</span>), JOBVR(<span class="charliteral">'V'</span>);
00469   <span class="keywordtype">long</span> LDA(N), LDVL(1), LDVR(N), LWORK(4*<a class="code" href="classzgematrix.html#o1">n</a>), INFO(1);
00470   <span class="keywordtype">double</span> *RWORK(<span class="keyword">new</span> <span class="keywordtype">double</span>[2*<a class="code" href="classzgematrix.html#o1">n</a>]);
00471   std::complex&lt;double&gt; *VL(NULL), *WORK(<span class="keyword">new</span> std::complex&lt;double&gt;[LWORK]);
00472   zgeev_(JOBVL, JOBVR, N, <a class="code" href="classzgematrix.html#r2">Array</a>, LDA, &amp;w[0], 
00473          VL, LDVL, VR.<a class="code" href="classzgematrix.html#r2">Array</a>, LDVR, WORK, LWORK, RWORK, INFO);
00474   <span class="keyword">delete</span> [] RWORK; <span class="keyword">delete</span> [] WORK; <span class="keyword">delete</span> [] VL;
00475   <span class="comment"></span>
00476 <span class="comment">  //// forming ////</span>
00477 <span class="comment"></span>  <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j=0; j&lt;N; j++){  <span class="keywordflow">for</span>(<span class="keywordtype">long</span> <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>=0; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>&lt;N; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>++){
00478     vr[j](<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>) = VR(<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>,j);
00479   }}
00480   
00481   <span class="keywordflow">if</span>(INFO!=0){
00482     std::cerr &lt;&lt; <span class="stringliteral">"[WARNING] zgematrix::zgesv"</span>
00483               &lt;&lt; <span class="stringliteral">"(std::vector&lt;std::complex&lt;double&gt;&amp;, std::vector&lt;zcovector&gt;&amp;) "</span>
00484               &lt;&lt; <span class="stringliteral">"Serious trouble happend. INFO = "</span> &lt;&lt; INFO &lt;&lt; <span class="stringliteral">"."</span>
00485               &lt;&lt; std::endl;
00486   }
00487   <span class="keywordflow">return</span> INFO;
00488 }
00489 
00490 <span class="comment">//=============================================================================</span><span class="comment"></span>
00491 <span class="comment">/*! calculate eigenvalues and left eigenvectors\n</span>
00492 <span class="comment">  All of the arguments need not to be initialized.</span>
00493 <span class="comment">  w, vr are overwitten and become eigenvalues and left eigenvectors, </span>
00494 <span class="comment">  respectively. </span>
00495 <span class="comment">  This matrix is also overwritten. */</span>
<a name="l00496"></a><a class="code" href="classzgematrix.html#a34">00496</a> <span class="keyword">inline</span> <span class="keywordtype">long</span> <a class="code" href="classzgematrix.html#a32">zgematrix::zgeev</a>(std::vector&lt; std::complex&lt;double&gt; &gt;&amp; w,
00497                              std::vector&lt;zrovector&gt;&amp; vl)
00498 {
00499 <span class="preprocessor">#ifdef  CPPL_VERBOSE</span>
00500 <span class="preprocessor"></span>  std::cerr &lt;&lt; <span class="stringliteral">"# [MARK] zgematrix::zgeev(std::vector&lt; std::complex&lt;double&gt; &gt;&amp;, std::vector&lt;zrovector&gt;&amp;)"</span>
00501             &lt;&lt; std::endl;
00502 <span class="preprocessor">#endif//CPPL_VERBOSE</span>
00503 <span class="preprocessor"></span>  
00504 <span class="preprocessor">#ifdef  CPPL_DEBUG</span>
00505 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(<a class="code" href="classzgematrix.html#r0">M</a>!=<a class="code" href="classzgematrix.html#r1">N</a>){
00506     std::cerr &lt;&lt; <span class="stringliteral">"[ERROR] zgematrix::zgeev"</span>
00507               &lt;&lt; <span class="stringliteral">"(std::vector&lt;std::complex&lt;double&gt;&gt;&amp;, std::vector&lt;zrovector&gt;&amp;)"</span>
00508               &lt;&lt; std::endl
00509               &lt;&lt; <span class="stringliteral">"This matrix cannot have eigenvalues."</span> &lt;&lt; std::endl
00510               &lt;&lt; <span class="stringliteral">"Your input was ("</span> &lt;&lt; <a class="code" href="classzgematrix.html#r0">M</a> &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; <a class="code" href="classzgematrix.html#r1">N</a> &lt;&lt; <span class="stringliteral">")."</span> &lt;&lt; std::endl;
00511     exit(1);
00512   }
00513 <span class="preprocessor">#endif//CPPL_DEBUG</span>
00514 <span class="preprocessor"></span>  
00515   w.<a class="code" href="classzgematrix.html#a23">resize</a>(<a class="code" href="classzgematrix.html#r1">N</a>);  vl.<a class="code" href="classzgematrix.html#a23">resize</a>(<a class="code" href="classzgematrix.html#r1">N</a>);
00516   <span class="keywordflow">for</span>(<span class="keywordtype">long</span> <a class="code" href="classzgematrix.html#n15">i</a>=0; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>&lt;<a class="code" href="classzgematrix.html#r1">N</a>; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>++){ vl[<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>].<a class="code" href="classzgematrix.html#a23">resize</a>(N); }
00517   <a class="code" href="classzgematrix.html">zgematrix</a> VL(N,N);
00518   <span class="keywordtype">char</span> JOBVL(<span class="charliteral">'V'</span>), JOBVR(<span class="charliteral">'N'</span>);
00519   <span class="keywordtype">long</span> LDA(N), LDVL(N), LDVR(1), LWORK(4*<a class="code" href="classzgematrix.html#o1">n</a>), INFO(1);
00520   <span class="keywordtype">double</span> *RWORK(<span class="keyword">new</span> <span class="keywordtype">double</span>[2*<a class="code" href="classzgematrix.html#o1">n</a>]);
00521   std::complex&lt;double&gt; *VR(NULL), *WORK(<span class="keyword">new</span> std::complex&lt;double&gt;[LWORK]);
00522   zgeev_(JOBVL, JOBVR, N, <a class="code" href="classzgematrix.html#r2">Array</a>, LDA, &amp;w[0], 
00523          VL.<a class="code" href="classzgematrix.html#r2">Array</a>, LDVL, VR, LDVR, WORK, LWORK, RWORK, INFO);
00524   <span class="keyword">delete</span> [] RWORK; <span class="keyword">delete</span> [] WORK; <span class="keyword">delete</span> [] VR;
00525   <span class="comment"></span>
00526 <span class="comment">  //// forming ////</span>
00527 <span class="comment"></span>  <span class="keywordflow">for</span>(<span class="keywordtype">long</span> j=0; j&lt;N; j++){ <span class="keywordflow">for</span>(<span class="keywordtype">long</span> <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>=0; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>&lt;N; <a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>++){
00528     vl[j](<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>) = <a class="code" href="__zcovector-calc_8hpp.html#a1">std::conj</a>(VL(<a class="code" href="__dgbmatrix-calc_8hpp.html#a1">i</a>,j));
00529   }}
00530   
00531   <span class="keywordflow">if</span>(INFO!=0){
00532     std::cerr &lt;&lt; <span class="stringliteral">"[WARNING] zgematrix::zgesv"</span>
00533               &lt;&lt; <span class="stringliteral">"(std::vector&lt;std::complex&lt;double&gt;&amp;, std::vector&lt;zrovector&gt;&amp;) "</span>
00534               &lt;&lt; <span class="stringliteral">"Serious trouble happend. INFO = "</span> &lt;&lt; INFO &lt;&lt; <span class="stringliteral">"."</span>
00535               &lt;&lt; std::endl;
00536   }
00537   <span class="keywordflow">return</span> INFO;
00538 }
00539 
00540 <span class="comment"></span>
00541 <span class="comment">///////////////////////////////////////////////////////////////////////////////</span>
00542 <span class="comment">///////////////////////////////////////////////////////////////////////////////</span>
00543 <span class="comment">///////////////////////////////////////////////////////////////////////////////</span>
00544 <span class="comment"></span>
00545 <span class="comment">//=============================================================================</span>
00546 <span class="comment">//inline long zgematrix::zgegv()</span>
00547 
00548 <span class="comment"></span>
00549 <span class="comment">///////////////////////////////////////////////////////////////////////////////</span>
00550 <span class="comment">///////////////////////////////////////////////////////////////////////////////</span>
00551 <span class="comment">///////////////////////////////////////////////////////////////////////////////</span>
00552 <span class="comment"></span>
00553 <span class="comment">//=============================================================================</span><span class="comment"></span>
00554 <span class="comment">/*! compute the singular value decomposition (SVD)\n</span>
00555 <span class="comment">  The arguments are zcocector S, zgematrix U and VT.</span>
00556 <span class="comment">  All of them need not to be initialized.</span>
00557 <span class="comment">  S, U and VT are overwitten and become singular values, left singular vectors,</span>
00558 <span class="comment">  and right singular vectors respectively.</span>
00559 <span class="comment">  This matrix also overwritten.</span>
00560 <span class="comment">*/</span>
<a name="l00561"></a><a class="code" href="classzgematrix.html#a35">00561</a> <span class="keyword">inline</span> <span class="keywordtype">long</span> <a class="code" href="classzgematrix.html#a35">zgematrix::zgesvd</a>(<a class="code" href="classdcovector.html">dcovector</a>&amp; S, <a class="code" href="classzgematrix.html">zgematrix</a>&amp; U, <a class="code" href="classzgematrix.html">zgematrix</a>&amp; VT)
00562 {
00563 <span class="preprocessor">#ifdef  CPPL_VERBOSE</span>
00564 <span class="preprocessor"></span>  std::cerr &lt;&lt; <span class="stringliteral">"# [MARK] zgematrix::zgesvd(dcovector&amp;, zgematrix&amp;, zgematrix&amp;)"</span>
00565             &lt;&lt; std::endl;
00566 <span class="preprocessor">#endif//CPPL_VERBOSE</span>
00567 <span class="preprocessor"></span>  
00568   <span class="keywordtype">char</span> JOBU(<span class="charliteral">'A'</span>), JOBVT(<span class="charliteral">'A'</span>);
00569   <span class="keywordtype">long</span> LDA(<a class="code" href="classzgematrix.html#r0">M</a>), LDU(<a class="code" href="classzgematrix.html#r0">M</a>), LDVT(<a class="code" href="classzgematrix.html#r1">N</a>),
00570     LWORK(max(3*min(<a class="code" href="classzgematrix.html#o0">m</a>,<a class="code" href="classzgematrix.html#o1">n</a>)+max(<a class="code" href="classzgematrix.html#o0">m</a>,<a class="code" href="classzgematrix.html#o1">n</a>),5*min(<a class="code" href="classzgematrix.html#o0">m</a>,<a class="code" href="classzgematrix.html#o1">n</a>))), INFO(1);
00571   <span class="keywordtype">double</span> *RWORK(<span class="keyword">new</span> <span class="keywordtype">double</span>[5*min(<a class="code" href="classzgematrix.html#o0">m</a>,<a class="code" href="classzgematrix.html#o1">n</a>)]);
00572   std::complex&lt;double&gt; *WORK(<span class="keyword">new</span> std::complex&lt;double&gt;[LWORK]);
00573   S.resize(min(<a class="code" href="classzgematrix.html#r0">M</a>,<a class="code" href="classzgematrix.html#r1">N</a>)); U.resize(LDU,<a class="code" href="classzgematrix.html#r0">M</a>); VT.resize(LDVT,<a class="code" href="classzgematrix.html#r1">N</a>);
00574   
00575   zgesvd_(JOBU, JOBVT, <a class="code" href="classzgematrix.html#r0">M</a>, <a class="code" href="classzgematrix.html#r1">N</a>, <a class="code" href="classzgematrix.html#r2">Array</a>, LDA, S.array, U.Array, 
00576           LDU, VT.Array, LDVT, WORK, LWORK, RWORK, INFO);
00577   <span class="keyword">delete</span> [] RWORK; <span class="keyword">delete</span> [] WORK;
00578   
00579   <span class="keywordflow">if</span>(INFO!=0){
00580     std::cerr &lt;&lt; <span class="stringliteral">"[WARNING] zgematrix::zgesvd"</span>
00581               &lt;&lt; <span class="stringliteral">"(dceovector&amp;, zgematrix&amp;, zcovector&amp;) "</span>
00582               &lt;&lt; <span class="stringliteral">"Serious trouble happend. INFO = "</span> &lt;&lt; INFO &lt;&lt; <span class="stringliteral">"."</span>
00583               &lt;&lt; std::endl;
00584   }
00585   <span class="keywordflow">return</span> INFO;
00586 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Mar 25 17:28:24 2005 for CPPLapack by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.1 </small></address>
</body>
</html>
